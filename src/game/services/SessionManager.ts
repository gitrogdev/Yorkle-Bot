import Session from '../entities/Session.js';
import type OpenSessionResponse from '../model/OpenSessionResponse.js';
import type UserIdentity from '../model/UserIdentity.js';
import type PostgameDiscussionPort from '../ports/PostgameDiscussionPort.js';
import type SongQueue from './SongQueue.js';

export default class SessionManager {
	/** A map of user IDs to the open session associated with them. */
	private sessions: Map<string, Session> = new Map();

	/**
	 * Creates a new session manager.
	 *
	 * @author gitrog
	 *
	 * @param {number[]} clipLengths an array of numbers containing the lengths
	 * in seconds of each clip generated by the game
	 * @param {SongQueue} queue the queue to get the songs from
	 * @param {PostgameDiscussionPort} postgameManager the port to use to
	 * manage postgame discussion threads
	 */
	constructor(
		private readonly clipLengths: number[],
		private queue: SongQueue,
		private readonly postgameManager: PostgameDiscussionPort
	) {}

	/**
	 * Gets the open session for the user.
	 *
	 * @author gitrog
	 *
	 * @param {UserIdentity} user the user to get the open session for
	 *
	 * @returns {Session | undefined} the open session for the user, if exists
	 */
	public getSession(user: UserIdentity): Session | undefined {
		return this.sessions.get(user.id);
	}

	/**
	 * Opens a new session for a user.
	 *
	 * @author gitrog
	 *
	 * @param {UserIdentity} user the user opening the session
	 *
	 * @returns {Promise<OpenSessionResponse>} a Promise of the open session
	 * response, containing the session if opened
	 */
	public async open(user: UserIdentity): Promise<OpenSessionResponse> {
		if (this.sessions.has(user.id)) {
			console.error(
				`Failed to open session for ${user.name}: Session already open `
				+ `with ID ${user.id}!`
			);
			return {
				result: 'COLLISION'
			};
		}

		const game = await this.queue.getGame();
		if (game.hasPlayed(user.id)) {
			console.error(
				`Failed to open session for ${user.name}: User with `
				+ `ID ${user.id} has already played Yorkle #${game.day}!`
			);
			return {
				result: 'PLAYED'
			};
		}

		const session = new Session(
			user,
			game,
			this.clipLengths.length,
			this.close.bind(this)
		);
		this.sessions.set(user.id, session);
		return {
			result: 'OPEN',
			session: session
		};
	}

	/**
	 * Closes the session for a user.
	 *
	 * @author gitrog
	 *
	 * @param {UserIdentity} user the user to close the session for
	 */
	public close(user: UserIdentity) {
		const session = this.sessions.get(user.id);
		if (!session) {
			console.error(
				`Failed to close session for ${user.name}: Session not found.`
			);
			return;
		};

		this.sessions.delete(user.id);
		console.log(
			`Successfully closed Yorkle #${session.getDay()} session for `
			+ `${user.name}.`
		);

		this.postgameManager.joinPostgameThreads(user, session.getDay());
	}
}